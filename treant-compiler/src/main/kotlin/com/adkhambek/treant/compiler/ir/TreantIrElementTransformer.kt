package com.adkhambek.treant.compiler.ir

import com.adkhambek.treant.compiler.LoggerStrategy
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.backend.common.lower.DeclarationIrBuilder
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.declarations.IrDeclarationOrigin
import org.jetbrains.kotlin.ir.declarations.IrProperty
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.util.kotlinFqName
import org.jetbrains.kotlin.ir.util.parentClassOrNull
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid

// ==============================================================================
// IR Element Transformer
// ==============================================================================
//
// This transformer walks the IR tree (via IrElementTransformerVoid) and looks
// for properties that were generated by our FIR extension. For each one it
// finds, it fills in the backing field's initializer expression.
//
// Example — for a class annotated with @Slf4j:
//
//   BEFORE (after FIR, property has no body):
//     private val log: org.slf4j.Logger    // backing field = null initializer
//
//   AFTER (this transformer fills it in):
//     private val log: org.slf4j.Logger =
//         LoggerFactory.getLogger(Class.forName("com.example.MyService"))
//
// The transformer identifies "our" properties by checking the declaration
// origin. If a property was GeneratedByPlugin with a key we recognize
// (Slf4jDeclarationKey or JulDeclarationKey), we know it's ours.
// ==============================================================================

@OptIn(UnsafeDuringIrConstructionAPI::class)
class TreantIrElementTransformer(
    private val pluginContext: IrPluginContext,
) : IrElementTransformerVoid() {

    // Called for every IrProperty in the module. We only modify ours.
    override fun visitProperty(declaration: IrProperty): IrStatement {
        // 1. Check if this property was generated by a compiler plugin.
        //    User-written properties have origin like IrDeclarationOrigin.DEFINED.
        //    Plugin-generated ones have IrDeclarationOrigin.GeneratedByPlugin.
        val origin = declaration.origin as? IrDeclarationOrigin.GeneratedByPlugin
            ?: return super.visitProperty(declaration)

        // 2. Get the plugin key that was stamped during the FIR phase.
        //    This tells us WHICH plugin generated it.
        val pluginKey = origin.pluginKey ?: return super.visitProperty(declaration)

        // 3. Look up the LoggerStrategy that owns this key.
        //    If the key doesn't belong to us (e.g. another plugin), skip.
        val strategy = LoggerStrategy.fromKey(pluginKey)
            ?: return super.visitProperty(declaration)

        // 4. Verify the property name matches (e.g. "log").
        //    A safety check in case multiple properties share the same key.
        if (declaration.name != strategy.propertyName) return super.visitProperty(declaration)

        // 5. Navigate the IR tree to find the outer class name.
        //    IR structure:  OuterClass > Companion > property
        //    parentClassOrNull goes up one level each time.
        val parentClass = declaration.parentClassOrNull ?: return super.visitProperty(declaration)
        val outerClass = parentClass.parentClassOrNull ?: return super.visitProperty(declaration)

        // 6. Get the fully qualified name (e.g. "com.example.MyService").
        //    This is passed to LoggerFactory.getLogger() or Logger.getLogger().
        val outerFqName = outerClass.kotlinFqName.asString()

        // 7. Get the backing field — this is where the initializer lives.
        val backingField = declaration.backingField ?: return super.visitProperty(declaration)

        // 8. Create an IR builder anchored to the backing field's source position.
        //    This ensures correct line numbers in stack traces and debugger.
        val builder = DeclarationIrBuilder(pluginContext, backingField.symbol)

        // 9. Delegate to the strategy to build the framework-specific IR.
        //    Slf4j → LoggerFactory.getLogger(Class.forName("..."))
        //    Jul   → Logger.getLogger("...")
        val initExpression = strategy.buildInitializer(builder, pluginContext, outerFqName)

        // 10. Assign the initializer to the backing field.
        //     After this, the property is fully functional.
        backingField.initializer = pluginContext.irFactory.createExpressionBody(
            backingField.startOffset,
            backingField.endOffset,
            initExpression,
        )

        // 11. Return the modified property (not super — we handled it).
        return declaration
    }
}
