package com.adkhambek.treant.idea

import com.intellij.lang.documentation.AbstractDocumentationProvider
import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.analysis.api.analyze
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.psi.KtClassOrObject
import org.jetbrains.kotlin.psi.KtObjectDeclaration
import org.jetbrains.kotlin.psi.KtProperty

class TreantDocumentationProvider : AbstractDocumentationProvider() {

    private val treantClassId = ClassId(
        FqName("com.adkhambek.treant"),
        Name.identifier("Slf4j"),
    )

    override fun generateDoc(element: PsiElement, originalElement: PsiElement?): String? {
        val property = element as? KtProperty ?: return null
        val propName = property.name ?: return null
        if (propName != "logger") return null

        val companion = property.parent?.parent as? KtObjectDeclaration ?: return null
        if (!companion.isCompanion()) return null
        val ownerClass = companion.parent?.parent as? KtClassOrObject ?: return null
        val ownerFqName = ownerClass.fqName?.asString() ?: return null
        if (!hasTreantAnnotation(ownerClass)) return null

        return buildString {
            append("<div class='definition'><pre>")
            append("private val logger: Logger = LoggerFactory.getLogger($ownerFqName::class.java)")
            append("</pre></div>")
            append("<div class='content'>")
            append("<p><i>Generated by the SLF4J compiler plugin</i></p>")
            append("<p>SLF4J Logger instance for the enclosing class.</p>")
            append("</div>")
        }
    }

    private fun hasTreantAnnotation(classOrObject: KtClassOrObject): Boolean {
        analyze(classOrObject) {
            val symbol = classOrObject.symbol
            return symbol.annotations.any { it.classId == treantClassId }
        }
    }
}
