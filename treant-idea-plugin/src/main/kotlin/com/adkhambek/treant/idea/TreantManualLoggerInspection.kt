package com.adkhambek.treant.idea

import com.intellij.codeInspection.LocalInspectionTool
import com.intellij.codeInspection.ProblemsHolder
import com.intellij.psi.PsiElementVisitor
import org.jetbrains.kotlin.analysis.api.analyze
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.psi.KtClassOrObject
import org.jetbrains.kotlin.psi.KtObjectDeclaration
import org.jetbrains.kotlin.psi.KtProperty
import org.jetbrains.kotlin.psi.KtVisitorVoid

class TreantManualLoggerInspection : LocalInspectionTool() {

    private val treantClassId = ClassId(
        FqName("com.adkhambek.treant"),
        Name.identifier("Slf4j"),
    )

    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
        return object : KtVisitorVoid() {
            override fun visitProperty(property: KtProperty) {
                val name = property.name ?: return
                if (name != "logger") return

                val companion = property.parent?.parent as? KtObjectDeclaration ?: return
                if (!companion.isCompanion()) return
                val ownerClass = companion.parent?.parent as? KtClassOrObject ?: return
                if (!hasTreantAnnotation(ownerClass)) return

                holder.registerProblem(
                    property.nameIdentifier ?: property,
                    "'logger' is automatically generated by the SLF4J compiler plugin for @Slf4j classes. This manual definition will conflict with the generated logger.",
                )
            }
        }
    }

    private fun hasTreantAnnotation(classOrObject: KtClassOrObject): Boolean {
        analyze(classOrObject) {
            val symbol = classOrObject.symbol
            return symbol.annotations.any { it.classId == treantClassId }
        }
    }
}
